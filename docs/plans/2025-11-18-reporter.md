# Reporter Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build terminal and HTML reporters that display test results with visual clarity, configurable verbosity, and interactive image comparison.

**Architecture:** Plugin-based reporter interface with TerminalReporter (colored CLI output) and HTMLReporter (single-page HTML with overlay slider). Reporters are called by orchestrator after saving results.

**Tech Stack:** TypeScript, Node.js, ANSI color codes, vanilla HTML/CSS/JS (no frameworks)

**Related Design:** docs/plans/2025-11-18-reporter-design.md

---

## Task 1: Add ReporterPlugin Interface

**Files:**
- Modify: `src/types/plugins.ts`
- Test: `src/types/plugins.test.ts`

**Step 1: Write the failing test**

Add to `src/types/plugins.test.ts`:

```typescript
describe('ReporterPlugin interface', () => {
  it('should accept valid ReporterPlugin implementation', () => {
    const mockReporter: ReporterPlugin = {
      generate: async (result: RunResult, options: ReporterOptions) => {
        // Mock implementation
      }
    };

    expect(mockReporter.generate).toBeDefined();
    expect(typeof mockReporter.generate).toBe('function');
  });

  it('should accept valid ReporterOptions', () => {
    const options: ReporterOptions = {
      verbosity: 'normal',
      outputDir: '/path/to/output',
      embedImages: false,
      autoOpen: false
    };

    expect(options.verbosity).toBe('normal');
    expect(options.embedImages).toBe(false);
  });

  it('should accept all verbosity levels', () => {
    const levels: Array<'quiet' | 'normal' | 'verbose'> = ['quiet', 'normal', 'verbose'];

    levels.forEach(level => {
      const options: ReporterOptions = { verbosity: level };
      expect(options.verbosity).toBe(level);
    });
  });
});
```

**Step 2: Run test to verify it fails**

```bash
cd /Users/dylanr/Dropbox\ (Personal)/work/2389/visual-uat/.worktrees/reporter
npm test -- plugins.test.ts
```

Expected: FAIL with "Cannot find name 'ReporterPlugin'"

**Step 3: Write minimal implementation**

Add to `src/types/plugins.ts`:

```typescript
import { RunResult } from '../orchestrator/types/results';

export interface ReporterOptions {
  verbosity?: 'quiet' | 'normal' | 'verbose';
  outputDir?: string;
  embedImages?: boolean;
  autoOpen?: boolean;
}

export interface ReporterPlugin {
  generate(result: RunResult, options: ReporterOptions): Promise<void>;
}
```

**Step 4: Run test to verify it passes**

```bash
npm test -- plugins.test.ts
```

Expected: PASS (all tests including new reporter tests)

**Step 5: Commit**

```bash
git add src/types/plugins.ts src/types/plugins.test.ts
git commit -m "feat(types): add ReporterPlugin interface

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 2: Create TerminalReporter with Quiet Mode

**Files:**
- Create: `src/plugins/terminal-reporter.ts`
- Create: `src/plugins/terminal-reporter.test.ts`

**Step 1: Write the failing test**

```typescript
// src/plugins/terminal-reporter.test.ts
import { TerminalReporter } from './terminal-reporter';
import { RunResult } from '../orchestrator/types/results';
import { ReporterOptions } from '../types/plugins';

describe('TerminalReporter', () => {
  let output: string[];
  let originalLog: typeof console.log;

  beforeEach(() => {
    output = [];
    originalLog = console.log;
    console.log = jest.fn((...args) => {
      output.push(args.join(' '));
    });
  });

  afterEach(() => {
    console.log = originalLog;
  });

  describe('quiet mode', () => {
    it('should show only summary in quiet mode', async () => {
      const reporter = new TerminalReporter();
      const result: RunResult = {
        timestamp: Date.now(),
        baseBranch: 'main',
        currentBranch: 'feature/test',
        config: {} as any,
        tests: [
          {
            specPath: 'tests/login.md',
            generatedPath: 'tests/generated/login.spec.ts',
            status: 'passed',
            checkpoints: [],
            duration: 1200,
            baselineAvailable: true
          },
          {
            specPath: 'tests/broken.md',
            generatedPath: 'tests/generated/broken.spec.ts',
            status: 'failed',
            checkpoints: [],
            duration: 800,
            baselineAvailable: true
          }
        ],
        summary: {
          total: 2,
          passed: 1,
          failed: 1,
          errored: 0,
          needsReview: 0
        }
      };

      const options: ReporterOptions = {
        verbosity: 'quiet',
        outputDir: '.visual-uat/reports'
      };

      await reporter.generate(result, options);

      // Should show summary line
      expect(output.some(line => line.includes('Visual UAT Complete'))).toBe(true);
      expect(output.some(line => line.includes('1 passed'))).toBe(true);
      expect(output.some(line => line.includes('1 failed'))).toBe(true);

      // Should NOT show individual test lines
      expect(output.some(line => line.includes('login'))).toBe(false);
      expect(output.some(line => line.includes('broken'))).toBe(false);
    });

    it('should show report path if outputDir provided', async () => {
      const reporter = new TerminalReporter();
      const result: RunResult = {
        timestamp: 1700000000000,
        baseBranch: 'main',
        currentBranch: 'feature/test',
        config: {} as any,
        tests: [],
        summary: { total: 0, passed: 0, failed: 0, errored: 0, needsReview: 0 }
      };

      await reporter.generate(result, { verbosity: 'quiet', outputDir: '.visual-uat/reports' });

      expect(output.some(line => line.includes('Report:'))).toBe(true);
      expect(output.some(line => line.includes('.visual-uat/reports'))).toBe(true);
    });
  });
});
```

**Step 2: Run test to verify it fails**

```bash
npm test -- terminal-reporter.test.ts
```

Expected: FAIL with "Cannot find module './terminal-reporter'"

**Step 3: Write minimal implementation**

```typescript
// src/plugins/terminal-reporter.ts
// ABOUTME: Terminal reporter plugin that outputs test results to stdout with configurable verbosity.
// ABOUTME: Supports quiet (summary only), normal (per-test status), and verbose (full details) modes.

import { ReporterPlugin, ReporterOptions } from '../types/plugins';
import { RunResult } from '../orchestrator/types/results';
import * as path from 'path';

export class TerminalReporter implements ReporterPlugin {
  async generate(result: RunResult, options: ReporterOptions): Promise<void> {
    const verbosity = options.verbosity || 'normal';

    if (verbosity === 'quiet') {
      this.printQuiet(result, options);
    }
  }

  private printQuiet(result: RunResult, options: ReporterOptions): void {
    console.log('Visual UAT Complete');

    const parts: string[] = [];
    if (result.summary.passed > 0) parts.push(`${result.summary.passed} passed`);
    if (result.summary.needsReview > 0) parts.push(`${result.summary.needsReview} needs review`);
    if (result.summary.failed > 0) parts.push(`${result.summary.failed} failed`);
    if (result.summary.errored > 0) parts.push(`${result.summary.errored} errored`);

    console.log('  ' + parts.join(', '));

    if (options.outputDir) {
      const reportPath = this.getReportPath(result.timestamp, options.outputDir);
      console.log(`  Report: ${reportPath}`);
    }
  }

  private getReportPath(timestamp: number, outputDir: string): string {
    const date = new Date(timestamp);
    const formatted = date.toISOString().slice(0, 19).replace(/[:T]/g, '-');
    return path.join(outputDir, `${formatted}.html`);
  }
}
```

**Step 4: Run test to verify it passes**

```bash
npm test -- terminal-reporter.test.ts
```

Expected: PASS

**Step 5: Commit**

```bash
git add src/plugins/terminal-reporter.ts src/plugins/terminal-reporter.test.ts
git commit -m "feat(reporter): add TerminalReporter with quiet mode

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 3: Add Normal and Verbose Modes to TerminalReporter

**Files:**
- Modify: `src/plugins/terminal-reporter.ts`
- Modify: `src/plugins/terminal-reporter.test.ts`

**Step 1: Write the failing test**

Add to `src/plugins/terminal-reporter.test.ts`:

```typescript
describe('normal mode', () => {
  it('should show test-by-test status in normal mode', async () => {
    const reporter = new TerminalReporter();
    const result: RunResult = {
      timestamp: Date.now(),
      baseBranch: 'main',
      currentBranch: 'feature/test',
      config: {} as any,
      tests: [
        {
          specPath: 'tests/login.md',
          generatedPath: 'tests/generated/login.spec.ts',
          status: 'passed',
          checkpoints: [],
          duration: 1200,
          baselineAvailable: true
        },
        {
          specPath: 'tests/dashboard.md',
          generatedPath: 'tests/generated/dashboard.spec.ts',
          status: 'needs-review',
          checkpoints: [
            {
              name: 'initial',
              baselineImage: '',
              currentImage: '',
              diffImage: '',
              diffMetrics: { pixelDiffPercent: 2.3, changedRegions: [] },
              evaluation: { pass: false, confidence: 0.8, reason: 'Layout shifted', needsReview: true }
            }
          ],
          duration: 2100,
          baselineAvailable: true
        },
        {
          specPath: 'tests/broken.md',
          generatedPath: 'tests/generated/broken.spec.ts',
          status: 'failed',
          checkpoints: [],
          duration: 800,
          error: 'Button position changed',
          baselineAvailable: true
        }
      ],
      summary: { total: 3, passed: 1, failed: 1, errored: 0, needsReview: 1 }
    };

    await reporter.generate(result, { verbosity: 'normal' });

    // Should show header
    expect(output.some(line => line.includes('feature/test vs main'))).toBe(true);

    // Should show each test with status
    expect(output.some(line => line.includes('âœ“') && line.includes('login'))).toBe(true);
    expect(output.some(line => line.includes('âš ') && line.includes('dashboard'))).toBe(true);
    expect(output.some(line => line.includes('âœ—') && line.includes('broken'))).toBe(true);

    // Should show summary
    expect(output.some(line => line.includes('Summary'))).toBe(true);
  });
});

describe('verbose mode', () => {
  it('should show detailed information in verbose mode', async () => {
    const reporter = new TerminalReporter();
    const result: RunResult = {
      timestamp: Date.now(),
      baseBranch: 'main',
      currentBranch: 'feature/test',
      config: {} as any,
      tests: [
        {
          specPath: 'tests/dashboard.md',
          generatedPath: 'tests/generated/dashboard.spec.ts',
          status: 'needs-review',
          checkpoints: [
            {
              name: 'initial',
              baselineImage: '',
              currentImage: '',
              diffImage: '',
              diffMetrics: { pixelDiffPercent: 2.3, changedRegions: [] },
              evaluation: { pass: false, confidence: 0.8, reason: 'Layout shifted slightly', needsReview: true }
            }
          ],
          duration: 2100,
          baselineAvailable: true
        }
      ],
      summary: { total: 1, passed: 0, failed: 0, errored: 0, needsReview: 1 }
    };

    await reporter.generate(result, { verbosity: 'verbose' });

    // Should show checkpoint details
    expect(output.some(line => line.includes('initial'))).toBe(true);
    expect(output.some(line => line.includes('2.3%'))).toBe(true);
    expect(output.some(line => line.includes('Layout shifted'))).toBe(true);
  });
});
```

**Step 2: Run test to verify it fails**

```bash
npm test -- terminal-reporter.test.ts
```

Expected: FAIL (new tests fail because normal/verbose not implemented)

**Step 3: Write implementation**

Update `src/plugins/terminal-reporter.ts`:

```typescript
async generate(result: RunResult, options: ReporterOptions): Promise<void> {
  const verbosity = options.verbosity || 'normal';

  if (verbosity === 'quiet') {
    this.printQuiet(result, options);
  } else if (verbosity === 'normal') {
    this.printNormal(result, options);
  } else if (verbosity === 'verbose') {
    this.printVerbose(result, options);
  }
}

private printNormal(result: RunResult, options: ReporterOptions): void {
  console.log(`Running tests: ${result.currentBranch} vs ${result.baseBranch}`);

  for (const test of result.tests) {
    const icon = this.getStatusIcon(test.status);
    const name = path.basename(test.specPath, '.md');
    const duration = this.formatDuration(test.duration);

    let line = `  ${icon} ${name} (${duration})`;

    if (test.status === 'needs-review' && test.checkpoints.length > 0) {
      const maxDiff = Math.max(...test.checkpoints.map(c => c.diffMetrics.pixelDiffPercent));
      line += ` - ${maxDiff.toFixed(1)}% diff, needs review`;
    } else if (test.status === 'failed' && test.error) {
      line += ` - ${test.error}`;
    }

    console.log(line);
  }

  console.log();
  this.printSummary(result);

  if (options.outputDir) {
    const reportPath = this.getReportPath(result.timestamp, options.outputDir);
    console.log(`Report: ${reportPath}`);
  }
}

private printVerbose(result: RunResult, options: ReporterOptions): void {
  console.log(`Running tests: ${result.currentBranch} vs ${result.baseBranch}`);

  for (const test of result.tests) {
    const icon = this.getStatusIcon(test.status);
    const name = path.basename(test.specPath, '.md');
    const duration = this.formatDuration(test.duration);

    console.log(`  ${icon} ${name} (${duration})`);

    if (!test.baselineAvailable) {
      console.log('      No baseline available');
    }

    for (const checkpoint of test.checkpoints) {
      const diffPercent = checkpoint.diffMetrics.pixelDiffPercent.toFixed(1);
      const evalIcon = checkpoint.evaluation.pass ? 'âœ“' : 'âœ—';

      console.log(`      ${evalIcon} ${checkpoint.name}: ${diffPercent}% diff`);
      console.log(`         ${checkpoint.evaluation.reason}`);
      console.log(`         Confidence: ${(checkpoint.evaluation.confidence * 100).toFixed(0)}%`);
    }

    if (test.error) {
      console.log(`      Error: ${test.error}`);
    }
  }

  console.log();
  this.printSummary(result);

  if (options.outputDir) {
    const reportPath = this.getReportPath(result.timestamp, options.outputDir);
    console.log(`Report: ${reportPath}`);
  }
}

private getStatusIcon(status: string): string {
  switch (status) {
    case 'passed': return 'âœ“';
    case 'needs-review': return 'âš ';
    case 'failed': return 'âœ—';
    case 'errored': return 'âŠ˜';
    default: return '?';
  }
}

private formatDuration(ms: number): string {
  if (ms < 1000) return `${ms}ms`;
  return `${(ms / 1000).toFixed(1)}s`;
}

private printSummary(result: RunResult): void {
  const parts: string[] = [];
  if (result.summary.passed > 0) parts.push(`${result.summary.passed} passed`);
  if (result.summary.needsReview > 0) parts.push(`${result.summary.needsReview} needs review`);
  if (result.summary.failed > 0) parts.push(`${result.summary.failed} failed`);
  if (result.summary.errored > 0) parts.push(`${result.summary.errored} errored`);

  console.log('Summary: ' + parts.join(', '));
}
```

**Step 4: Run test to verify it passes**

```bash
npm test -- terminal-reporter.test.ts
```

Expected: PASS (all tests)

**Step 5: Commit**

```bash
git add src/plugins/terminal-reporter.ts src/plugins/terminal-reporter.test.ts
git commit -m "feat(reporter): add normal and verbose modes to TerminalReporter

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 4: Add RunId to RunResult

**Files:**
- Modify: `src/orchestrator/types/results.ts`
- Modify: `src/orchestrator/types/results.test.ts`
- Create: `src/orchestrator/services/run-id-generator.ts`
- Create: `src/orchestrator/services/run-id-generator.test.ts`

**Step 1: Write the failing test**

Add to `src/orchestrator/services/run-id-generator.test.ts`:

```typescript
import { generateRunId } from './run-id-generator';

describe('generateRunId', () => {
  it('should generate 7-character hash', () => {
    const runId = generateRunId();
    expect(runId).toHaveLength(7);
    expect(runId).toMatch(/^[a-f0-9]{7}$/);
  });

  it('should generate unique IDs', () => {
    const id1 = generateRunId();
    const id2 = generateRunId();
    expect(id1).not.toBe(id2);
  });
});
```

Add to `src/orchestrator/types/results.test.ts`:

```typescript
describe('RunResult with runId', () => {
  it('should include runId in RunResult', () => {
    const result: RunResult = {
      runId: 'a3f7b9c',
      timestamp: Date.now(),
      baseBranch: 'main',
      currentBranch: 'feature/test',
      config: {} as any,
      tests: [],
      summary: { total: 0, passed: 0, failed: 0, errored: 0, needsReview: 0 }
    };

    expect(result.runId).toBe('a3f7b9c');
    expect(result.runId).toHaveLength(7);
  });
});
```

**Step 2: Run test to verify it fails**

```bash
npm test -- run-id-generator.test.ts
npm test -- results.test.ts
```

Expected: FAIL (module not found, runId property missing)

**Step 3: Write implementation**

```typescript
// src/orchestrator/services/run-id-generator.ts
// ABOUTME: Generates unique short run IDs for test executions.
// ABOUTME: Uses crypto to create 7-character hex strings for identifying runs.

import * as crypto from 'crypto';

export function generateRunId(): string {
  return crypto.randomBytes(4).toString('hex').slice(0, 7);
}
```

Update `src/orchestrator/types/results.ts`:

```typescript
export interface RunResult {
  runId: string; // ADD THIS LINE
  timestamp: number;
  baseBranch: string;
  currentBranch: string;
  config: Config;
  tests: TestResult[];
  summary: {
    total: number;
    passed: number;
    failed: number;
    errored: number;
    needsReview: number;
  };
}
```

**Step 4: Run test to verify it passes**

```bash
npm test -- run-id-generator.test.ts
npm test -- results.test.ts
```

Expected: PASS

**Step 5: Commit**

```bash
git add src/orchestrator/services/run-id-generator.ts src/orchestrator/services/run-id-generator.test.ts src/orchestrator/types/results.ts src/orchestrator/types/results.test.ts
git commit -m "feat(orchestrator): add runId to RunResult

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 5: Update TerminalReporter to Show RunId

**Files:**
- Modify: `src/plugins/terminal-reporter.ts`
- Modify: `src/plugins/terminal-reporter.test.ts`

**Step 1: Write the failing test**

Add to `src/plugins/terminal-reporter.test.ts`:

```typescript
it('should show runId in all verbosity modes', async () => {
  const reporter = new TerminalReporter();
  const result: RunResult = {
    runId: 'a3f7b9c',
    timestamp: Date.now(),
    baseBranch: 'main',
    currentBranch: 'feature/test',
    config: {} as any,
    tests: [],
    summary: { total: 0, passed: 0, failed: 0, errored: 0, needsReview: 0 }
  };

  await reporter.generate(result, { verbosity: 'quiet' });
  expect(output.some(line => line.includes('Run ID: a3f7b9c'))).toBe(true);
});
```

**Step 2: Run test to verify it fails**

```bash
npm test -- terminal-reporter.test.ts
```

Expected: FAIL (runId not shown in output)

**Step 3: Write implementation**

Update methods in `src/plugins/terminal-reporter.ts`:

```typescript
private printQuiet(result: RunResult, options: ReporterOptions): void {
  console.log('Visual UAT Complete');

  const parts: string[] = [];
  if (result.summary.passed > 0) parts.push(`${result.summary.passed} passed`);
  if (result.summary.needsReview > 0) parts.push(`${result.summary.needsReview} needs review`);
  if (result.summary.failed > 0) parts.push(`${result.summary.failed} failed`);
  if (result.summary.errored > 0) parts.push(`${result.summary.errored} errored`);

  console.log('  ' + parts.join(', '));

  if (options.outputDir) {
    const reportPath = this.getReportPath(result.timestamp, result.runId, options.outputDir);
    console.log(`  Report: ${reportPath}`);
  }

  console.log(`  Run ID: ${result.runId}`); // ADD THIS
}

private printNormal(result: RunResult, options: ReporterOptions): void {
  // ... existing code ...

  if (options.outputDir) {
    const reportPath = this.getReportPath(result.timestamp, result.runId, options.outputDir);
    console.log(`Report: ${reportPath}`);
  }
  console.log(`Run ID: ${result.runId}`); // ADD THIS
}

private printVerbose(result: RunResult, options: ReporterOptions): void {
  // ... existing code ...

  if (options.outputDir) {
    const reportPath = this.getReportPath(result.timestamp, result.runId, options.outputDir);
    console.log(`Report: ${reportPath}`);
  }
  console.log(`Run ID: ${result.runId}`); // ADD THIS
}

private getReportPath(timestamp: number, runId: string, outputDir: string): string {
  const date = new Date(timestamp);
  const formatted = date.toISOString().slice(0, 19).replace(/[:T]/g, '-');
  return path.join(outputDir, `${formatted}-${runId}.html`); // UPDATED
}
```

**Step 4: Run test to verify it passes**

```bash
npm test -- terminal-reporter.test.ts
```

Expected: PASS

**Step 5: Commit**

```bash
git add src/plugins/terminal-reporter.ts src/plugins/terminal-reporter.test.ts
git commit -m "feat(reporter): show runId in terminal output

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 6: Create HTMLReporter Basic Structure

**Files:**
- Create: `src/plugins/html-reporter.ts`
- Create: `src/plugins/html-reporter.test.ts`

**Step 1: Write the failing test**

```typescript
// src/plugins/html-reporter.test.ts
import { HTMLReporter } from './html-reporter';
import { RunResult } from '../orchestrator/types/results';
import * as fs from 'fs';
import * as path from 'path';

describe('HTMLReporter', () => {
  const testOutputDir = '.visual-uat/test-reports';

  beforeEach(() => {
    // Clean test output directory
    if (fs.existsSync(testOutputDir)) {
      fs.rmSync(testOutputDir, { recursive: true });
    }
    fs.mkdirSync(testOutputDir, { recursive: true });
  });

  afterEach(() => {
    // Cleanup
    if (fs.existsSync(testOutputDir)) {
      fs.rmSync(testOutputDir, { recursive: true });
    }
  });

  it('should generate HTML file with correct filename', async () => {
    const reporter = new HTMLReporter();
    const result: RunResult = {
      runId: 'a3f7b9c',
      timestamp: new Date('2024-11-18T14:30:22Z').getTime(),
      baseBranch: 'main',
      currentBranch: 'feature/test',
      config: {} as any,
      tests: [],
      summary: { total: 0, passed: 0, failed: 0, errored: 0, needsReview: 0 }
    };

    await reporter.generate(result, { outputDir: testOutputDir });

    const expectedFile = path.join(testOutputDir, '2024-11-18-14-30-22-a3f7b9c.html');
    expect(fs.existsSync(expectedFile)).toBe(true);
  });

  it('should include basic HTML structure', async () => {
    const reporter = new HTMLReporter();
    const result: RunResult = {
      runId: 'a3f7b9c',
      timestamp: Date.now(),
      baseBranch: 'main',
      currentBranch: 'feature/test',
      config: {} as any,
      tests: [],
      summary: { total: 0, passed: 0, failed: 0, errored: 0, needsReview: 0 }
    };

    await reporter.generate(result, { outputDir: testOutputDir });

    const files = fs.readdirSync(testOutputDir);
    const htmlFile = path.join(testOutputDir, files[0]);
    const content = fs.readFileSync(htmlFile, 'utf-8');

    expect(content).toContain('<!DOCTYPE html>');
    expect(content).toContain('<html');
    expect(content).toContain('</html>');
    expect(content).toContain('<title>Visual UAT Report</title>');
  });

  it('should include run metadata in header', async () => {
    const reporter = new HTMLReporter();
    const result: RunResult = {
      runId: 'a3f7b9c',
      timestamp: Date.now(),
      baseBranch: 'main',
      currentBranch: 'feature/test',
      config: {} as any,
      tests: [],
      summary: { total: 0, passed: 0, failed: 0, errored: 0, needsReview: 0 }
    };

    await reporter.generate(result, { outputDir: testOutputDir });

    const files = fs.readdirSync(testOutputDir);
    const htmlFile = path.join(testOutputDir, files[0]);
    const content = fs.readFileSync(htmlFile, 'utf-8');

    expect(content).toContain('feature/test');
    expect(content).toContain('main');
    expect(content).toContain('a3f7b9c');
  });
});
```

**Step 2: Run test to verify it fails**

```bash
npm test -- html-reporter.test.ts
```

Expected: FAIL with "Cannot find module './html-reporter'"

**Step 3: Write minimal implementation**

```typescript
// src/plugins/html-reporter.ts
// ABOUTME: HTML reporter plugin that generates single-page HTML report with test results.
// ABOUTME: Includes interactive image comparison, filtering, and embedded styling.

import { ReporterPlugin, ReporterOptions } from '../types/plugins';
import { RunResult } from '../orchestrator/types/results';
import * as fs from 'fs';
import * as path from 'path';

export class HTMLReporter implements ReporterPlugin {
  async generate(result: RunResult, options: ReporterOptions): Promise<void> {
    const outputDir = options.outputDir || '.visual-uat/reports';
    fs.mkdirSync(outputDir, { recursive: true });

    const filename = this.generateFilename(result.timestamp, result.runId);
    const filepath = path.join(outputDir, filename);

    const html = this.generateHTML(result, options);
    fs.writeFileSync(filepath, html, 'utf-8');
  }

  private generateFilename(timestamp: number, runId: string): string {
    const date = new Date(timestamp);
    const formatted = date.toISOString().slice(0, 19).replace(/[:T]/g, '-');
    return `${formatted}-${runId}.html`;
  }

  private generateHTML(result: RunResult, options: ReporterOptions): string {
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visual UAT Report</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
    }
    .header {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .metadata {
      display: flex;
      gap: 20px;
      margin-top: 10px;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Visual UAT Report</h1>
    <div class="metadata">
      <div><strong>Branch:</strong> ${result.currentBranch}</div>
      <div><strong>Base:</strong> ${result.baseBranch}</div>
      <div><strong>Run ID:</strong> ${result.runId}</div>
      <div><strong>Date:</strong> ${new Date(result.timestamp).toLocaleString()}</div>
    </div>
  </div>
</body>
</html>`;
  }
}
```

**Step 4: Run test to verify it passes**

```bash
npm test -- html-reporter.test.ts
```

Expected: PASS

**Step 5: Commit**

```bash
git add src/plugins/html-reporter.ts src/plugins/html-reporter.test.ts
git commit -m "feat(reporter): create HTMLReporter basic structure

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 7: Add Summary Boxes to HTMLReporter

**Files:**
- Modify: `src/plugins/html-reporter.ts`
- Modify: `src/plugins/html-reporter.test.ts`

**Step 1: Write the failing test**

Add to `src/plugins/html-reporter.test.ts`:

```typescript
it('should include summary boxes with counts', async () => {
  const reporter = new HTMLReporter();
  const result: RunResult = {
    runId: 'a3f7b9c',
    timestamp: Date.now(),
    baseBranch: 'main',
    currentBranch: 'feature/test',
    config: {} as any,
    tests: [],
    summary: { total: 10, passed: 5, failed: 2, errored: 1, needsReview: 2 }
  };

  await reporter.generate(result, { outputDir: testOutputDir });

  const files = fs.readdirSync(testOutputDir);
  const htmlFile = path.join(testOutputDir, files[0]);
  const content = fs.readFileSync(htmlFile, 'utf-8');

  expect(content).toContain('5'); // passed count
  expect(content).toContain('2'); // needs review count
  expect(content).toContain('2'); // failed count
  expect(content).toContain('1'); // errored count
  expect(content).toContain('class="summary-box');
});
```

**Step 2: Run test to verify it fails**

```bash
npm test -- html-reporter.test.ts
```

Expected: FAIL (summary boxes not present)

**Step 3: Write implementation**

Update `generateHTML` method in `src/plugins/html-reporter.ts`:

```typescript
private generateHTML(result: RunResult, options: ReporterOptions): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visual UAT Report</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
    }
    .header {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .metadata {
      display: flex;
      gap: 20px;
      margin-top: 10px;
      color: #666;
    }
    .summary {
      display: flex;
      gap: 15px;
      margin-top: 20px;
    }
    .summary-box {
      flex: 1;
      padding: 20px;
      border-radius: 6px;
      text-align: center;
      cursor: pointer;
      transition: transform 0.2s;
    }
    .summary-box:hover {
      transform: scale(1.05);
    }
    .summary-box.passed {
      background: #10b981;
      color: white;
    }
    .summary-box.needs-review {
      background: #f59e0b;
      color: white;
    }
    .summary-box.failed {
      background: #ef4444;
      color: white;
    }
    .summary-box.errored {
      background: #6b7280;
      color: white;
    }
    .summary-box .count {
      font-size: 36px;
      font-weight: bold;
    }
    .summary-box .label {
      font-size: 14px;
      text-transform: uppercase;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Visual UAT Report</h1>
    <div class="metadata">
      <div><strong>Branch:</strong> ${result.currentBranch}</div>
      <div><strong>Base:</strong> ${result.baseBranch}</div>
      <div><strong>Run ID:</strong> ${result.runId}</div>
      <div><strong>Date:</strong> ${new Date(result.timestamp).toLocaleString()}</div>
    </div>
    <div class="summary">
      <div class="summary-box passed" data-filter="passed">
        <div class="count">${result.summary.passed}</div>
        <div class="label">Passed</div>
      </div>
      <div class="summary-box needs-review" data-filter="needs-review">
        <div class="count">${result.summary.needsReview}</div>
        <div class="label">Needs Review</div>
      </div>
      <div class="summary-box failed" data-filter="failed">
        <div class="count">${result.summary.failed}</div>
        <div class="label">Failed</div>
      </div>
      <div class="summary-box errored" data-filter="errored">
        <div class="count">${result.summary.errored}</div>
        <div class="label">Errored</div>
      </div>
    </div>
  </div>
</body>
</html>`;
}
```

**Step 4: Run test to verify it passes**

```bash
npm test -- html-reporter.test.ts
```

Expected: PASS

**Step 5: Commit**

```bash
git add src/plugins/html-reporter.ts src/plugins/html-reporter.test.ts
git commit -m "feat(reporter): add summary boxes to HTML report

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 8: Add Test List to HTMLReporter

**Files:**
- Modify: `src/plugins/html-reporter.ts`
- Modify: `src/plugins/html-reporter.test.ts`

**Step 1: Write the failing test**

Add to `src/plugins/html-reporter.test.ts`:

```typescript
it('should list all tests with status', async () => {
  const reporter = new HTMLReporter();
  const result: RunResult = {
    runId: 'a3f7b9c',
    timestamp: Date.now(),
    baseBranch: 'main',
    currentBranch: 'feature/test',
    config: {} as any,
    tests: [
      {
        specPath: 'tests/login.md',
        generatedPath: 'tests/generated/login.spec.ts',
        status: 'passed',
        checkpoints: [],
        duration: 1200,
        baselineAvailable: true
      },
      {
        specPath: 'tests/dashboard.md',
        generatedPath: 'tests/generated/dashboard.spec.ts',
        status: 'needs-review',
        checkpoints: [],
        duration: 2100,
        baselineAvailable: true
      }
    ],
    summary: { total: 2, passed: 1, failed: 0, errored: 0, needsReview: 1 }
  };

  await reporter.generate(result, { outputDir: testOutputDir });

  const files = fs.readdirSync(testOutputDir);
  const htmlFile = path.join(testOutputDir, files[0]);
  const content = fs.readFileSync(htmlFile, 'utf-8');

  expect(content).toContain('login');
  expect(content).toContain('dashboard');
  expect(content).toContain('1.2s'); // formatted duration
  expect(content).toContain('2.1s');
  expect(content).toContain('class="test-card');
});
```

**Step 2: Run test to verify it fails**

```bash
npm test -- html-reporter.test.ts
```

Expected: FAIL (test list not present)

**Step 3: Write implementation**

Update `generateHTML` method to add test list section:

```typescript
private generateHTML(result: RunResult, options: ReporterOptions): string {
  const testCardsHTML = result.tests.map(test => this.generateTestCard(test)).join('\n');

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visual UAT Report</title>
  <style>
    /* ... existing styles ... */
    .tests {
      margin-top: 20px;
    }
    .test-card {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 15px;
      border-left: 4px solid #ccc;
    }
    .test-card.passed {
      border-left-color: #10b981;
    }
    .test-card.needs-review {
      border-left-color: #f59e0b;
    }
    .test-card.failed {
      border-left-color: #ef4444;
    }
    .test-card.errored {
      border-left-color: #6b7280;
    }
    .test-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }
    .test-name {
      font-size: 18px;
      font-weight: 600;
    }
    .test-status {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .test-status.passed {
      background: #d1fae5;
      color: #065f46;
    }
    .test-status.needs-review {
      background: #fed7aa;
      color: #92400e;
    }
    .test-status.failed {
      background: #fee2e2;
      color: #991b1b;
    }
    .test-status.errored {
      background: #e5e7eb;
      color: #1f2937;
    }
    .test-duration {
      color: #6b7280;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="header">
    <!-- ... existing header content ... -->
  </div>

  <div class="tests">
    ${testCardsHTML}
  </div>
</body>
</html>`;
}

private generateTestCard(test: TestResult): string {
  const name = path.basename(test.specPath, '.md');
  const duration = this.formatDuration(test.duration);
  const autoExpand = test.status === 'needs-review' || test.status === 'failed';

  return `
    <div class="test-card ${test.status}" data-status="${test.status}">
      <div class="test-header">
        <div>
          <span class="test-name">${name}</span>
          <span class="test-duration">${duration}</span>
        </div>
        <span class="test-status ${test.status}">${test.status}</span>
      </div>
    </div>
  `;
}

private formatDuration(ms: number): string {
  if (ms < 1000) return `${ms}ms`;
  return `${(ms / 1000).toFixed(1)}s`;
}
```

Also need to import TestResult at top:

```typescript
import { RunResult, TestResult } from '../orchestrator/types/results';
```

**Step 4: Run test to verify it passes**

```bash
npm test -- html-reporter.test.ts
```

Expected: PASS

**Step 5: Commit**

```bash
git add src/plugins/html-reporter.ts src/plugins/html-reporter.test.ts
git commit -m "feat(reporter): add test list to HTML report

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 9: Add Filtering to HTMLReporter

**Files:**
- Modify: `src/plugins/html-reporter.ts`
- Modify: `src/plugins/html-reporter.test.ts`

**Step 1: Write the failing test**

Add to `src/plugins/html-reporter.test.ts`:

```typescript
it('should include filter controls', async () => {
  const reporter = new HTMLReporter();
  const result: RunResult = {
    runId: 'a3f7b9c',
    timestamp: Date.now(),
    baseBranch: 'main',
    currentBranch: 'feature/test',
    config: {} as any,
    tests: [],
    summary: { total: 0, passed: 0, failed: 0, errored: 0, needsReview: 0 }
  };

  await reporter.generate(result, { outputDir: testOutputDir });

  const files = fs.readdirSync(testOutputDir);
  const htmlFile = path.join(testOutputDir, files[0]);
  const content = fs.readFileSync(htmlFile, 'utf-8');

  expect(content).toContain('class="filter-bar');
  expect(content).toContain('data-filter="all"');
  expect(content).toContain('data-filter="passed"');
  expect(content).toContain('data-filter="needs-review"');
  expect(content).toContain('data-filter="failed"');
});

it('should include filtering JavaScript', async () => {
  const reporter = new HTMLReporter();
  const result: RunResult = {
    runId: 'a3f7b9c',
    timestamp: Date.now(),
    baseBranch: 'main',
    currentBranch: 'feature/test',
    config: {} as any,
    tests: [],
    summary: { total: 0, passed: 0, failed: 0, errored: 0, needsReview: 0 }
  };

  await reporter.generate(result, { outputDir: testOutputDir });

  const files = fs.readdirSync(testOutputDir);
  const htmlFile = path.join(testOutputDir, files[0]);
  const content = fs.readFileSync(htmlFile, 'utf-8');

  expect(content).toContain('<script>');
  expect(content).toContain('addEventListener');
  expect(content).toContain('querySelectorAll');
});
```

**Step 2: Run test to verify it fails**

```bash
npm test -- html-reporter.test.ts
```

Expected: FAIL (filter bar and script not present)

**Step 3: Write implementation**

Update `generateHTML` to add filter bar and JavaScript:

```typescript
private generateHTML(result: RunResult, options: ReporterOptions): string {
  const testCardsHTML = result.tests.map(test => this.generateTestCard(test)).join('\n');

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visual UAT Report</title>
  <style>
    /* ... existing styles ... */
    .filter-bar {
      background: white;
      padding: 15px 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .filter-btn {
      padding: 8px 16px;
      border: 1px solid #d1d5db;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }
    .filter-btn:hover {
      background: #f3f4f6;
    }
    .filter-btn.active {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
    }
    .search-input {
      flex: 1;
      padding: 8px 16px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 14px;
    }
    .test-card.hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="header">
    <!-- ... existing header content ... -->
  </div>

  <div class="filter-bar">
    <button class="filter-btn active" data-filter="all">All</button>
    <button class="filter-btn" data-filter="passed">Passed</button>
    <button class="filter-btn" data-filter="needs-review">Needs Review</button>
    <button class="filter-btn" data-filter="failed">Failed</button>
    <button class="filter-btn" data-filter="errored">Errored</button>
    <input type="text" class="search-input" placeholder="Search tests..." id="searchInput">
  </div>

  <div class="tests">
    ${testCardsHTML}
  </div>

  <script>
    // Filter by status
    let currentFilter = 'all';
    let currentSearch = '';

    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentFilter = btn.dataset.filter;
        applyFilters();
      });
    });

    // Filter by search
    document.getElementById('searchInput').addEventListener('input', (e) => {
      currentSearch = e.target.value.toLowerCase();
      applyFilters();
    });

    // Click summary boxes to filter
    document.querySelectorAll('.summary-box').forEach(box => {
      box.addEventListener('click', () => {
        const filter = box.dataset.filter;
        document.querySelectorAll('.filter-btn').forEach(btn => {
          if (btn.dataset.filter === filter) {
            btn.click();
          }
        });
      });
    });

    function applyFilters() {
      document.querySelectorAll('.test-card').forEach(card => {
        const status = card.dataset.status;
        const name = card.querySelector('.test-name').textContent.toLowerCase();

        const matchesFilter = currentFilter === 'all' || status === currentFilter;
        const matchesSearch = currentSearch === '' || name.includes(currentSearch);

        if (matchesFilter && matchesSearch) {
          card.classList.remove('hidden');
        } else {
          card.classList.add('hidden');
        }
      });
    }
  </script>
</body>
</html>`;
}
```

**Step 4: Run test to verify it passes**

```bash
npm test -- html-reporter.test.ts
```

Expected: PASS

**Step 5: Commit**

```bash
git add src/plugins/html-reporter.ts src/plugins/html-reporter.test.ts
git commit -m "feat(reporter): add filtering to HTML report

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 10: Add Image Overlay Slider to HTMLReporter

**Files:**
- Modify: `src/plugins/html-reporter.ts`
- Modify: `src/plugins/html-reporter.test.ts`

**Step 1: Write the failing test**

Add to `src/plugins/html-reporter.test.ts`:

```typescript
it('should include checkpoint with image comparison', async () => {
  const reporter = new HTMLReporter();
  const result: RunResult = {
    runId: 'a3f7b9c',
    timestamp: Date.now(),
    baseBranch: 'main',
    currentBranch: 'feature/test',
    config: {} as any,
    tests: [
      {
        specPath: 'tests/dashboard.md',
        generatedPath: 'tests/generated/dashboard.spec.ts',
        status: 'needs-review',
        checkpoints: [
          {
            name: 'initial',
            baselineImage: '.visual-uat/screenshots/base/dashboard/initial.png',
            currentImage: '.visual-uat/screenshots/current/dashboard/initial.png',
            diffImage: '.visual-uat/diffs/dashboard/initial.png',
            diffMetrics: { pixelDiffPercent: 2.3, changedRegions: [] },
            evaluation: {
              pass: false,
              confidence: 0.8,
              reason: 'Layout shifted slightly',
              needsReview: true
            }
          }
        ],
        duration: 2100,
        baselineAvailable: true
      }
    ],
    summary: { total: 1, passed: 0, failed: 0, errored: 0, needsReview: 1 }
  };

  await reporter.generate(result, { outputDir: testOutputDir });

  const files = fs.readdirSync(testOutputDir);
  const htmlFile = path.join(testOutputDir, files[0]);
  const content = fs.readFileSync(htmlFile, 'utf-8');

  expect(content).toContain('class="checkpoint');
  expect(content).toContain('initial');
  expect(content).toContain('2.3%');
  expect(content).toContain('Layout shifted');
  expect(content).toContain('class="image-comparison');
  expect(content).toContain('type="range"'); // slider
});
```

**Step 2: Run test to verify it fails**

```bash
npm test -- html-reporter.test.ts
```

Expected: FAIL (checkpoint content not present)

**Step 3: Write implementation**

Update `generateTestCard` to include checkpoints:

```typescript
private generateTestCard(test: TestResult): string {
  const name = path.basename(test.specPath, '.md');
  const duration = this.formatDuration(test.duration);
  const autoExpand = test.status === 'needs-review' || test.status === 'failed';

  const checkpointsHTML = test.checkpoints.length > 0
    ? `<div class="test-body">${test.checkpoints.map(cp => this.generateCheckpoint(cp)).join('\n')}</div>`
    : '';

  return `
    <div class="test-card ${test.status}" data-status="${test.status}">
      <div class="test-header" onclick="this.parentElement.classList.toggle('expanded')">
        <div>
          <span class="test-name">${name}</span>
          <span class="test-duration">${duration}</span>
        </div>
        <span class="test-status ${test.status}">${test.status}</span>
      </div>
      ${checkpointsHTML}
    </div>
  `;
}

private generateCheckpoint(checkpoint: CheckpointResult): string {
  const diffPercent = checkpoint.diffMetrics.pixelDiffPercent.toFixed(1);
  const evalIcon = checkpoint.evaluation.pass ? 'âœ“' : 'âœ—';
  const confidence = (checkpoint.evaluation.confidence * 100).toFixed(0);

  return `
    <div class="checkpoint">
      <div class="checkpoint-header">
        <h3>${checkpoint.name}</h3>
        <div class="checkpoint-metrics">
          <span class="${checkpoint.evaluation.pass ? 'pass' : 'fail'}">${evalIcon}</span>
          <span>${diffPercent}% diff</span>
          <span>${confidence}% confidence</span>
        </div>
      </div>

      <div class="image-comparison">
        <div class="comparison-container">
          <img src="${checkpoint.baselineImage}" class="baseline-img" alt="Baseline">
          <img src="${checkpoint.currentImage}" class="current-img" alt="Current" style="clip-path: inset(0 50% 0 0);">
        </div>
        <input type="range" min="0" max="100" value="50" class="slider"
               onchange="updateSlider(this)" oninput="updateSlider(this)">

        <div class="view-modes">
          <button onclick="setViewMode(this, 'overlay')" class="active">Overlay</button>
          <button onclick="setViewMode(this, 'diff')">Diff</button>
          <button onclick="setViewMode(this, 'side-by-side')">Side by Side</button>
        </div>

        <img src="${checkpoint.diffImage}" class="diff-img" style="display: none;" alt="Diff">
      </div>

      <div class="evaluation">
        <strong>Evaluation:</strong> ${this.escapeHTML(checkpoint.evaluation.reason)}
      </div>
    </div>
  `;
}

private escapeHTML(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}
```

Add styles to `generateHTML`:

```typescript
<style>
  /* ... existing styles ... */
  .test-body {
    margin-top: 15px;
    display: none;
  }
  .test-card.expanded .test-body {
    display: block;
  }
  .checkpoint {
    padding: 20px;
    background: #f9fafb;
    border-radius: 6px;
    margin-bottom: 15px;
  }
  .checkpoint-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
  }
  .checkpoint-metrics {
    display: flex;
    gap: 15px;
    color: #6b7280;
  }
  .checkpoint-metrics .pass {
    color: #10b981;
  }
  .checkpoint-metrics .fail {
    color: #ef4444;
  }
  .image-comparison {
    margin: 15px 0;
  }
  .comparison-container {
    position: relative;
    width: 100%;
    max-width: 800px;
    margin: 0 auto;
    background: #000;
  }
  .comparison-container img {
    width: 100%;
    display: block;
  }
  .current-img {
    position: absolute;
    top: 0;
    left: 0;
  }
  .slider {
    width: 100%;
    max-width: 800px;
    display: block;
    margin: 10px auto;
  }
  .view-modes {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin: 10px 0;
  }
  .view-modes button {
    padding: 6px 12px;
    border: 1px solid #d1d5db;
    background: white;
    border-radius: 4px;
    cursor: pointer;
  }
  .view-modes button.active {
    background: #3b82f6;
    color: white;
    border-color: #3b82f6;
  }
  .evaluation {
    margin-top: 10px;
    padding: 10px;
    background: white;
    border-radius: 4px;
  }
</style>
```

Add JavaScript functions to the script section:

```typescript
<script>
  // ... existing filter code ...

  function updateSlider(slider) {
    const container = slider.previousElementSibling;
    const currentImg = container.querySelector('.current-img');
    const value = slider.value;
    currentImg.style.clipPath = \`inset(0 \${100 - value}% 0 0)\`;
  }

  function setViewMode(btn, mode) {
    const comparison = btn.closest('.image-comparison');
    const container = comparison.querySelector('.comparison-container');
    const slider = comparison.querySelector('.slider');
    const diffImg = comparison.querySelector('.diff-img');

    // Update active button
    comparison.querySelectorAll('.view-modes button').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');

    if (mode === 'overlay') {
      container.style.display = 'block';
      slider.style.display = 'block';
      diffImg.style.display = 'none';
    } else if (mode === 'diff') {
      container.style.display = 'none';
      slider.style.display = 'none';
      diffImg.style.display = 'block';
    } else if (mode === 'side-by-side') {
      // TODO: Implement side-by-side view
      alert('Side-by-side view coming soon');
    }
  }

  // Auto-expand failed/needs-review tests
  document.querySelectorAll('.test-card.needs-review, .test-card.failed').forEach(card => {
    card.classList.add('expanded');
  });
</script>
```

Need to import CheckpointResult:

```typescript
import { RunResult, TestResult, CheckpointResult } from '../orchestrator/types/results';
```

**Step 4: Run test to verify it passes**

```bash
npm test -- html-reporter.test.ts
```

Expected: PASS

**Step 5: Commit**

```bash
git add src/plugins/html-reporter.ts src/plugins/html-reporter.test.ts
git commit -m "feat(reporter): add image overlay slider to HTML report

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 11: Integrate Reporters into Orchestrator

**Files:**
- Modify: `src/orchestrator/handlers/run-command.ts`
- Modify: `src/orchestrator/handlers/run-command.test.ts`
- Modify: `src/orchestrator/services/plugin-registry.ts`
- Modify: `src/orchestrator/services/plugin-registry.test.ts`

**Step 1: Write the failing test**

Add to `src/orchestrator/handlers/run-command.test.ts`:

```typescript
import { TerminalReporter } from '../../plugins/terminal-reporter';
import { HTMLReporter } from '../../plugins/html-reporter';
import { generateRunId } from '../services/run-id-generator';

jest.mock('../services/run-id-generator');
const mockGenerateRunId = generateRunId as jest.MockedFunction<typeof generateRunId>;

describe('RunCommandHandler with reporters', () => {
  it('should call reporters after storing results', async () => {
    mockGenerateRunId.mockReturnValue('a3f7b9c');

    const mockTerminalGenerate = jest.fn();
    const mockHTMLGenerate = jest.fn();

    const mockPlugins = {
      generator: mockGenerator,
      differ: mockDiffer,
      evaluator: mockEvaluator,
      reporters: {
        terminal: { generate: mockTerminalGenerate } as any,
        html: { generate: mockHTMLGenerate } as any
      }
    };

    const handler = new RunCommandHandler(mockConfig, mockPlugins, '/project');

    // Mock other handlers to go straight to STORE_RESULTS
    handler['handleSetup'] = jest.fn().mockResolvedValue('STORE_RESULTS');
    handler['handleCleanup'] = jest.fn().mockResolvedValue('COMPLETE');

    const context: ExecutionContext = {
      scope: { type: 'full', baseBranch: 'main', specsToGenerate: [] },
      worktrees: null,
      baseResults: new Map(),
      currentResults: new Map(),
      runResult: {
        runId: 'a3f7b9c',
        timestamp: Date.now(),
        baseBranch: 'main',
        currentBranch: 'feature/test',
        config: mockConfig,
        tests: [],
        summary: { total: 0, passed: 0, failed: 0, errored: 0, needsReview: 0 }
      },
      keepWorktrees: false
    };

    const nextState = await handler['handleStoreResults'](context);

    expect(nextState).toBe('CLEANUP');
    expect(mockTerminalGenerate).toHaveBeenCalledWith(
      context.runResult,
      expect.objectContaining({ verbosity: 'normal' })
    );
    expect(mockHTMLGenerate).toHaveBeenCalledWith(
      context.runResult,
      expect.any(Object)
    );
  });
});
```

**Step 2: Run test to verify it fails**

```bash
npm test -- run-command.test.ts
```

Expected: FAIL (reporters not called)

**Step 3: Update plugin registry types**

Add to `src/orchestrator/services/plugin-registry.ts`:

```typescript
import { ReporterPlugin } from '../../types/plugins';
import { TerminalReporter } from '../../plugins/terminal-reporter';
import { HTMLReporter } from '../../plugins/html-reporter';

export interface LoadedPlugins {
  generator: TestGeneratorPlugin;
  differ: DifferPlugin;
  evaluator: EvaluatorPlugin;
  reporters: {
    terminal: ReporterPlugin;
    html: ReporterPlugin;
  };
}

export class PluginRegistry {
  async loadAll(): Promise<LoadedPlugins> {
    const generator = await this.loadGenerator();
    const differ = await this.loadDiffer();
    const evaluator = await this.loadEvaluator();
    const reporters = await this.loadReporters();

    return { generator, differ, evaluator, reporters };
  }

  private async loadReporters(): Promise<{ terminal: ReporterPlugin; html: ReporterPlugin }> {
    // For now, use default implementations
    // Future: Allow custom reporters from config
    return {
      terminal: new TerminalReporter(),
      html: new HTMLReporter()
    };
  }

  // ... existing methods ...
}
```

**Step 4: Update run-command handler**

Update `handleStoreResults` in `src/orchestrator/handlers/run-command.ts`:

```typescript
import { generateRunId } from '../services/run-id-generator';
import { ReporterOptions } from '../../types/plugins';
import * as path from 'path';

// In execute() method, generate runId when creating context:
async execute(options: RunOptions): Promise<number> {
  let state: ExecutionState = 'SETUP';
  const context: ExecutionContext = {
    scope: null,
    worktrees: null,
    baseResults: new Map<string, RawTestResult>(),
    currentResults: new Map<string, RawTestResult>(),
    runResult: null,
    keepWorktrees: options.keepWorktrees || false
  };

  // Store options for later use in handleStoreResults
  (this as any).runOptions = options;

  // ... rest of method
}

// Update handleStoreResults:
private async handleStoreResults(
  context: ExecutionContext
): Promise<ExecutionState> {
  try {
    // Generate runId if not already set
    if (!context.runResult!.runId) {
      context.runResult!.runId = generateRunId();
    }

    await this.resultStore.saveResult(context.runResult!);
    console.log('Results saved');

    // Generate reports
    const reporterOptions: ReporterOptions = {
      verbosity: this.getVerbosity(),
      outputDir: path.join(this.projectRoot, '.visual-uat/reports'),
      embedImages: false,
      autoOpen: false
    };

    // Terminal reporter (immediate feedback)
    await this.plugins.reporters.terminal.generate(context.runResult!, reporterOptions);

    // HTML reporter
    await this.plugins.reporters.html.generate(context.runResult!, reporterOptions);

    return 'CLEANUP';
  } catch (error) {
    console.error('Failed to store results or generate reports:', error);
    return 'FAILED';
  }
}

private getVerbosity(): 'quiet' | 'normal' | 'verbose' {
  const options = (this as any).runOptions as RunOptions;
  if (options.quiet) return 'quiet';
  if (options.verbose) return 'verbose';
  return 'normal';
}
```

**Step 5: Run test to verify it passes**

```bash
npm test -- run-command.test.ts
```

Expected: PASS

**Step 6: Run full test suite**

```bash
npm test
```

Expected: All tests pass

**Step 7: Commit**

```bash
git add src/orchestrator/handlers/run-command.ts src/orchestrator/handlers/run-command.test.ts src/orchestrator/services/plugin-registry.ts
git commit -m "feat(orchestrator): integrate reporters into execution flow

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 12: Add CLI Flags for Reporter Control

**Files:**
- Modify: `src/cli.ts`
- Modify: `src/cli.test.ts`
- Modify: `src/orchestrator/services/change-detector.ts`

**Step 1: Write the failing test**

Add to `src/cli.test.ts`:

```typescript
describe('CLI reporter flags', () => {
  it('should pass quiet flag to handler', async () => {
    const mockExecute = jest.fn().mockResolvedValue(0);

    await cli.parseAsync(['node', 'visual-uat', 'run', '--quiet']);

    expect(mockExecute).toHaveBeenCalledWith(
      expect.objectContaining({ quiet: true })
    );
  });

  it('should pass verbose flag to handler', async () => {
    const mockExecute = jest.fn().mockResolvedValue(0);

    await cli.parseAsync(['node', 'visual-uat', 'run', '--verbose']);

    expect(mockExecute).toHaveBeenCalledWith(
      expect.objectContaining({ verbose: true })
    );
  });

  it('should pass no-html flag to handler', async () => {
    const mockExecute = jest.fn().mockResolvedValue(0);

    await cli.parseAsync(['node', 'visual-uat', 'run', '--no-html']);

    expect(mockExecute).toHaveBeenCalledWith(
      expect.objectContaining({ noHtml: true })
    );
  });

  it('should pass open flag to handler', async () => {
    const mockExecute = jest.fn().mockResolvedValue(0);

    await cli.parseAsync(['node', 'visual-uat', 'run', '--open']);

    expect(mockExecute).toHaveBeenCalledWith(
      expect.objectContaining({ open: true })
    );
  });
});
```

**Step 2: Run test to verify it fails**

```bash
npm test -- cli.test.ts
```

Expected: FAIL (flags not passed to handler)

**Step 3: Update RunOptions interface**

In `src/orchestrator/services/change-detector.ts`:

```typescript
export interface RunOptions {
  baseBranch?: string;
  force?: boolean;
  keepWorktrees?: boolean;
  quiet?: boolean;       // ADD
  verbose?: boolean;     // ADD
  noHtml?: boolean;      // ADD
  open?: boolean;        // ADD
}
```

**Step 4: Update CLI**

In `src/cli.ts`:

```typescript
program
  .command('run')
  .description('Run visual acceptance tests')
  .option('--base-branch <branch>', 'Base branch for comparison', 'main')
  .option('--force', 'Force full run even if no changes detected')
  .option('--keep-worktrees', 'Keep worktrees after execution for debugging')
  .option('--quiet', 'Minimal terminal output (summary only)')
  .option('--verbose', 'Detailed terminal output with full information')
  .option('--no-html', 'Skip HTML report generation')
  .option('--open', 'Auto-open HTML report in browser')
  .action(async (options) => {
    const config = loadConfig(process.cwd());
    const registry = new PluginRegistry(config);
    const plugins = await registry.loadAll();
    const handler = new RunCommandHandler(config, plugins, process.cwd());

    const exitCode = await handler.execute({
      baseBranch: options.baseBranch,
      force: options.force,
      keepWorktrees: options.keepWorktrees,
      quiet: options.quiet,
      verbose: options.verbose,
      noHtml: options.noHtml,
      open: options.open
    });

    process.exit(exitCode);
  });
```

**Step 5: Update handleStoreResults to respect flags**

In `src/orchestrator/handlers/run-command.ts`:

```typescript
private async handleStoreResults(
  context: ExecutionContext
): Promise<ExecutionState> {
  try {
    if (!context.runResult!.runId) {
      context.runResult!.runId = generateRunId();
    }

    await this.resultStore.saveResult(context.runResult!);
    console.log('Results saved');

    const options = (this as any).runOptions as RunOptions;

    const reporterOptions: ReporterOptions = {
      verbosity: this.getVerbosity(),
      outputDir: path.join(this.projectRoot, '.visual-uat/reports'),
      embedImages: false,
      autoOpen: options.open || false
    };

    // Terminal reporter
    await this.plugins.reporters.terminal.generate(context.runResult!, reporterOptions);

    // HTML reporter (unless --no-html)
    if (!options.noHtml) {
      await this.plugins.reporters.html.generate(context.runResult!, reporterOptions);

      // Auto-open if requested
      if (options.open) {
        const reportPath = path.join(
          reporterOptions.outputDir!,
          `${this.formatTimestamp(context.runResult!.timestamp)}-${context.runResult!.runId}.html`
        );
        await this.openInBrowser(reportPath);
      }
    }

    return 'CLEANUP';
  } catch (error) {
    console.error('Failed to store results or generate reports:', error);
    return 'FAILED';
  }
}

private formatTimestamp(timestamp: number): string {
  const date = new Date(timestamp);
  return date.toISOString().slice(0, 19).replace(/[:T]/g, '-');
}

private async openInBrowser(filepath: string): Promise<void> {
  const { exec } = require('child_process');
  const command = process.platform === 'darwin' ? 'open' :
                  process.platform === 'win32' ? 'start' : 'xdg-open';
  exec(`${command} "${filepath}"`);
}
```

**Step 6: Run test to verify it passes**

```bash
npm test -- cli.test.ts
```

Expected: PASS

**Step 7: Run full test suite**

```bash
npm test
```

Expected: All tests pass

**Step 8: Commit**

```bash
git add src/cli.ts src/cli.test.ts src/orchestrator/services/change-detector.ts src/orchestrator/handlers/run-command.ts
git commit -m "feat(cli): add reporter control flags (--quiet, --verbose, --no-html, --open)

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 13: Add Config Options for Reporters

**Files:**
- Modify: `src/types/config.ts`
- Modify: `src/types/config.test.ts`
- Modify: `src/orchestrator/handlers/run-command.ts`

**Step 1: Write the failing test**

Add to `src/types/config.test.ts`:

```typescript
describe('Config with reporter options', () => {
  it('should accept reporter config', () => {
    const config: Config = {
      specsDir: 'tests',
      generatedDir: 'tests/generated',
      reporters: {
        terminal: {
          enabled: true,
          defaultVerbosity: 'normal'
        },
        html: {
          enabled: true,
          embedImages: false
        }
      }
    };

    expect(config.reporters?.terminal?.enabled).toBe(true);
    expect(config.reporters?.terminal?.defaultVerbosity).toBe('normal');
    expect(config.reporters?.html?.embedImages).toBe(false);
  });

  it('should allow all verbosity options', () => {
    const levels: Array<'quiet' | 'normal' | 'verbose'> = ['quiet', 'normal', 'verbose'];

    levels.forEach(level => {
      const config: Config = {
        specsDir: 'tests',
        generatedDir: 'tests/generated',
        reporters: {
          terminal: {
            enabled: true,
            defaultVerbosity: level
          }
        }
      };

      expect(config.reporters?.terminal?.defaultVerbosity).toBe(level);
    });
  });
});
```

**Step 2: Run test to verify it fails**

```bash
npm test -- config.test.ts
```

Expected: FAIL (reporters config not defined)

**Step 3: Update Config interface**

In `src/types/config.ts`:

```typescript
export interface Config {
  specsDir: string;
  generatedDir: string;
  plugins?: {
    generator?: string;
    differ?: string;
    evaluator?: string;
  };
  reporters?: {
    terminal?: {
      enabled?: boolean;
      defaultVerbosity?: 'quiet' | 'normal' | 'verbose';
    };
    html?: {
      enabled?: boolean;
      embedImages?: boolean;
    };
  };
}
```

**Step 4: Run test to verify it passes**

```bash
npm test -- config.test.ts
```

Expected: PASS

**Step 5: Update run-command to use config defaults**

In `src/orchestrator/handlers/run-command.ts`, update `getVerbosity` and `handleStoreResults`:

```typescript
private getVerbosity(): 'quiet' | 'normal' | 'verbose' {
  const options = (this as any).runOptions as RunOptions;

  // CLI flags override config
  if (options.quiet) return 'quiet';
  if (options.verbose) return 'verbose';

  // Use config default if set
  return this.config.reporters?.terminal?.defaultVerbosity || 'normal';
}

private async handleStoreResults(
  context: ExecutionContext
): Promise<ExecutionState> {
  try {
    if (!context.runResult!.runId) {
      context.runResult!.runId = generateRunId();
    }

    await this.resultStore.saveResult(context.runResult!);
    console.log('Results saved');

    const options = (this as any).runOptions as RunOptions;

    // Check if reporters are enabled in config
    const terminalEnabled = this.config.reporters?.terminal?.enabled !== false;
    const htmlEnabled = this.config.reporters?.html?.enabled !== false;

    const reporterOptions: ReporterOptions = {
      verbosity: this.getVerbosity(),
      outputDir: path.join(this.projectRoot, '.visual-uat/reports'),
      embedImages: this.config.reporters?.html?.embedImages || false,
      autoOpen: options.open || false
    };

    // Terminal reporter (if enabled)
    if (terminalEnabled) {
      await this.plugins.reporters.terminal.generate(context.runResult!, reporterOptions);
    }

    // HTML reporter (if enabled and not disabled by --no-html)
    if (htmlEnabled && !options.noHtml) {
      await this.plugins.reporters.html.generate(context.runResult!, reporterOptions);

      if (options.open) {
        const reportPath = path.join(
          reporterOptions.outputDir!,
          `${this.formatTimestamp(context.runResult!.timestamp)}-${context.runResult!.runId}.html`
        );
        await this.openInBrowser(reportPath);
      }
    }

    return 'CLEANUP';
  } catch (error) {
    console.error('Failed to store results or generate reports:', error);
    return 'FAILED';
  }
}
```

**Step 6: Run full test suite**

```bash
npm test
```

Expected: All tests pass

**Step 7: Commit**

```bash
git add src/types/config.ts src/types/config.test.ts src/orchestrator/handlers/run-command.ts
git commit -m "feat(config): add reporter configuration options

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 14: Integration Test and Documentation

**Files:**
- Create: `tests/integration/reporter.test.md`
- Modify: `README.md` (if exists) or create reporter usage docs

**Step 1: Create integration test document**

```markdown
# Reporter Integration Test

Manual test to verify reporter functionality end-to-end.

## Setup

```bash
cd /Users/dylanr/Dropbox\ (Personal)/work/2389/visual-uat/.worktrees/reporter
npm run build
```

## Test 1: Terminal Reporter - Normal Mode

```bash
npm run visual-uat run
```

**Expected:**
- Shows "Running tests: <branch> vs <base>"
- Lists each test with status icon and duration
- Shows summary line
- Shows report path and run ID

## Test 2: Terminal Reporter - Quiet Mode

```bash
npm run visual-uat run --quiet
```

**Expected:**
- Only shows summary line
- Shows report path and run ID
- No individual test lines

## Test 3: Terminal Reporter - Verbose Mode

```bash
npm run visual-uat run --verbose
```

**Expected:**
- Shows all normal mode output
- Plus checkpoint details
- Plus diff percentages
- Plus LLM evaluation reasoning

## Test 4: HTML Report Generation

```bash
npm run visual-uat run
ls -la .visual-uat/reports/
```

**Expected:**
- HTML file created with format: YYYY-MM-DD-HH-MM-SS-<runId>.html
- File contains test results
- Images display correctly

## Test 5: HTML Report Filtering

Open the HTML report in browser and test:

1. Click "Passed" filter - only passed tests show
2. Click "Failed" filter - only failed tests show
3. Type in search box - tests filter by name
4. Click summary box - filters to that status

## Test 6: Image Overlay Slider

Open report with visual differences:

1. Find a test with image diffs
2. Drag slider - should reveal baseline/current
3. Click "Diff" view - should show diff image
4. Verify LLM evaluation shows below images

## Test 7: CLI Flags

```bash
npm run visual-uat run --no-html
ls .visual-uat/reports/
```

**Expected:** No new HTML file created

```bash
npm run visual-uat run --open
```

**Expected:** HTML report opens in browser automatically

## Test 8: Config Options

Create `visual-uat.config.js`:

```javascript
module.exports = {
  specsDir: 'tests',
  generatedDir: 'tests/generated',
  reporters: {
    terminal: {
      enabled: true,
      defaultVerbosity: 'verbose'
    },
    html: {
      enabled: true,
      embedImages: true
    }
  }
};
```

Run: `npm run visual-uat run`

**Expected:**
- Verbose output by default
- HTML file is larger (embedded images)

## Verification

All tests should pass. If any fail, investigate and fix before merging.
```

Save to `tests/integration/reporter.test.md`

**Step 2: Document in README or usage guide**

Create or update documentation about reporter features:

```markdown
## Reporter Features

### Terminal Output

The terminal reporter provides immediate feedback with three verbosity levels:

- `--quiet`: Summary only
- Normal (default): Test-by-test status
- `--verbose`: Full details including checkpoint info

### HTML Reports

HTML reports are generated in `.visual-uat/reports/` with interactive features:

- **Filtering**: Click status boxes or use filter buttons
- **Search**: Find tests by name
- **Image Comparison**: Interactive overlay slider
- **View Modes**: Overlay, Diff, or Side-by-Side

### CLI Flags

```bash
visual-uat run                    # Normal terminal + HTML
visual-uat run --quiet            # Minimal terminal output
visual-uat run --verbose          # Detailed terminal output
visual-uat run --no-html          # Skip HTML generation
visual-uat run --open             # Auto-open HTML in browser
```

### Configuration

```javascript
// visual-uat.config.js
module.exports = {
  reporters: {
    terminal: {
      enabled: true,
      defaultVerbosity: 'normal'  // 'quiet' | 'normal' | 'verbose'
    },
    html: {
      enabled: true,
      embedImages: false  // true = base64, false = relative paths
    }
  }
};
```
```

**Step 3: Commit documentation**

```bash
git add tests/integration/reporter.test.md README.md
git commit -m "docs: add reporter integration tests and usage guide

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

**Step 4: Run final test suite**

```bash
npm test
npm run build
```

Expected: All tests pass, build succeeds

---

## Completion Checklist

When all tasks complete:

- [ ] ReporterPlugin interface defined
- [ ] TerminalReporter implemented (quiet, normal, verbose modes)
- [ ] HTMLReporter implemented with filtering
- [ ] Image overlay slider working
- [ ] RunId generated and displayed
- [ ] Reporters integrated into orchestrator
- [ ] CLI flags working (--quiet, --verbose, --no-html, --open)
- [ ] Config options working
- [ ] All unit tests pass
- [ ] Integration tests documented
- [ ] Usage documentation updated

## Next Steps After Implementation

1. Run integration tests manually
2. Test with real visual differences
3. Gather feedback on HTML report UX
4. Consider enhancements:
   - Side-by-side image view
   - Historical comparison
   - Export to other formats (JSON, JUnit XML)
   - Custom reporter plugins
